#
# Copyright (c) 2015-2022, Inversoft Inc., All Rights Reserved
#
# General Purpose PowerShell script to read in properties and run something as a service (RSaaS).
#
# @author Daniel DeGroff
# @version 1.0.0
# @version 1.1.0 - Removed configuration file processing, pushed back into *.bat files
#                  such that running catalina.bat, or elasticsearch.bat works properly.
#                - Create logging directories as needed
# @version 1.1.1 - Fix Service type detection
# @version 1.1.2 - Updated instructions only. Functionally the same as 1.1.1.
# @version 1.1.3 - Updated instructions only. Functionally the same as 1.1.2.
# @version 1.1.4 - Updated instructions only. Functionally the same as 1.1.3.
# @version 1.1.5 - Updated instructions only. Functionally the same as 1.1.4.
# @version 1.1.6 - The name is now pulled from the service script name.
# @version 1.1.7 - Assume the correct child process is the first Java process.
# @version 1.1.8 - Add support for modern powershell based start/stop scripts.
# -------------------------------------------------------------------------------------------------
# Instruction for use:
#
# 1. Copy this part into your project as part of your build
#    Most likely into the service bin directory
#
# 2. Depending on the application, you may need to rename this file.
#    * Tomcat is detected by looking for catalina.bat
#    * Elasticsearch is detected by looking for elasticsearch.bat
#    * An application with PowerShell scripts for start/stop is detected by looking for start.ps1
#    * Otherwise, the version you copy must be named the same as the corresponding batch file
#       Example: If you wish to run the 'GatherForum.bat' as a service, name this 'GatherForum.ps1'
#
# 3. Create the *.exe file
#    FusionAuth App Example:
#    > New-SelfHostedPS -SourceFile .\FusionAuthApp.ps1 -Service -ServiceName FusionAuthApp
#                                       -ServiceDisplayName "FusionAuth App"
#                                       -ServiceDescription "FusionAuth App Service provides the management interface and handles all API requests."
#                                       -Version 1.1.8
#
# 4. Register the service, replace with the appropriate *.exe file
#   > ./FusionAuthApp.exe /install
#
# 5. Start the service:
#   > net start FusionAuthApp
#
# 6. Stop the service:
#   > net stop FusionAuthApp
#
# 7. Unregister the service
#  > ./FusionAuthApp.exe /uninstall
#
# -------------------------------------------------------------------------------------------------

# Global Variables
$global:command = $null
$global:serviceHome = $null
$global:startCommand = $null
$global:stopCommand = $null
$global:isTomcat = $null
$global:isElastic = $null
$global:isPowerShell = $null
$global:isBatch = $false
$global:serviceName = $null
$global:serviceLogFile = $null

# Default Window Style
$global:windowStyle = "Hidden"

# Main function - Required by self-hosted PowerShell exe generated by New-SelfHostedPS provided by Daniel Sörlöv
function Main() {

  setupGlobalVariables
  $process = $null

  try {
    while($true) {

      # Get Application Name
      $appName = $global:serviceName.ToLower()

      # Exit if the expected start command is not found.
      If (-Not (Test-Path $global:startCommand)) {
        log "Error. Expected command not found. [$($global:startCommand)]"
        Exit 1
      }

      # Run the bat file in a new process.
      If ($global:isTomcat) {
        log "  Service type [Tomcat]"
        # Set CATALINA_HOME, this needs to be set here because catalina.bat won't detect it properly when running as a service.
        [Environment]::SetEnvironmentVariable("CATALINA_HOME", $global:serviceHome, "Process")
        log "  Set Process-Level Environment Variable : CATALINA_HOME=$([Environment]::GetEnvironmentVariable('CATALINA_HOME', 'Process'))"
        $process = startProcess $global:startCommand "run" $appName
      } Else {
        If ($global:isElastic) {
          log " Service type [Elastic]"
        } Else {
          log " Service type [$($global:serviceName)]"
        }
        # Do not pass a $null or empty string as the argument, it will not end well for you.
        $process = startProcess $global:startCommand " " $appName
      }

      log "  Process Path [$($process.path)], Process Id [$($process.Id)]"

      # Sleep long enough so we can reliably get the child process after potentially downloading Java
      Start-Sleep -m 2000

      # Find the Java child process, try for a while, during the first start we may have to download Java first.
      $attempts = 0
      while ($attempts -lt 35)
      {
        $javaPid = $((Get-WmiObject Win32_Process -Property ProcessId -Filter "ParentProcessId = $($process.Id) AND name = 'java.exe'").ProcessId)
        If ($javaPid)
        {
          $process = Get-Process -Id $javaPid
          break
        }

        log "Waiting for startup..."
        Start-Sleep -m 5000
        $attempts = $attempts + 1
      }

      log "Process started. Main process id [$($process.Id)]"
      Start-Sleep -m 2000

      # Once we've started the process, hang out here until we're done.
      while ($process -And !$process.HasExited) {
        $process = Get-Process -Id $process.Id -ErrorAction Ignore
        Start-Sleep -m 7000
      }
      log "Process [$($process.Id)] has ended. Exit."
      Exit
    }

  } finally {
    # Stop service
    log "Service is stopping, stop our process [$($serviceName)] using process id [$($process.Id)]"
    try {
      If ($process -And !$process.HasExited) {
        # If a stop command has been defined use, otherwise kill the process using Stop-Process
        If ($global:stopCommand) {
          If ($global.isTomcat) {
            $stopProcess = startProcess $global:stopCommand "stop" $appName
          } ElseIf ($global.isPowerShell) {
            $stopProcess = startProcess $global:stopCommand " " $appName
          } Else {
            # Do not pass a $null or empty string as the argument, it will not end well for you.
            $stopProcess = startProcess $global:stopCommand " " $appName
          }
          Wait-Process -Id $stopProcess.Id -Timeout 10
          # If we still have not exited the main process, call Stop-Process
          If (!$process.HasExited) {
            Stop-Process $process.Id
          }
        } Else {
          Stop-Process $process.Id
        }
        log "Successfully stopped"
      } Else {
        log "Process found to be already stopped."
      }
    } catch {
      log "Failed to stop. Exiting. You may need to manually kill the process."
    }
  }
}

function startProcess {
  Param([string]$command, [string]$arguments, [string]$appName)
  If ($global:windowStyle.equals("Hidden")) {
    If ($global:isPowerShell) {
      $argList = "-ExecutionPolicy ByPass -File ${command}"
      If (![string]::IsNullOrWhitespace($arguments)) {
        $argList += " ${arguments}"
      }
      $argList += " 2>&1"
      return Start-Process `
                    PowerShell `
                    -ArgumentList $argList `
                    -PassThru `
                    -WindowStyle $global:windowStyle
    } Else {
      return Start-Process $command "${arguments} 2>&1" `
                    -PassThru `
                    -WindowStyle $global:windowStyle
    }
  } Else {
    If ($global:isPowerShell) {
      $argList = "-ExecutionPolicy ByPass -File ${command}"
      If (![string]::IsNullOrWhitespace($arguments)) {
        $argList += " ${arguments}"
      }
      return Start-Process `
                    PowerShell `
                    -ArgumentList $argList `
                    -PassThru `
                    -WindowStyle $global:windowStyle
    } Else {
      return Start-Process `
                    $command $arguments `
                    -PassThru `
                    -WindowStyle $global:windowStyle
    }
  }
}

function setupGlobalVariables {
  $global:command = [Environment]::GetCommandLineArgs()
  # If running interactive in PS, use $PSCommandPath
  If ($global:command -like "*PowerShell*") {
    $global:command = $PSCommandPath
  }

  $global:serviceHome = (Get-Item $command).Directory.Parent.FullName
  $global:serviceName = (Get-Item $command).Basename

  $global:isTomcat = isTomcatService $global:serviceHome
  $global:isElastic = isElasticService $global:serviceHome
  $global:isPowerShell = isPowerShellStartup $global:serviceHome

  # Use specific known commands for Tomcat and Elastic, else check for ${serviceHome}\bin\start.ps1, else assume
  # we'll find a .bat file by the same name as this PowerShell script. i.e. FooService.ps1 --> FooService.bat
  If ($global:isTomcat) {
    $global:startCommand = "$($serviceHome)\bin\catalina.bat"
    $global:stopCommand = "$($serviceHome)\bin\catalina.bat"
  } ElseIf ($global:isElastic) {
    $global:startCommand = "$($serviceHome)\bin\elasticsearch.bat"
  } ElseIf ($global:isPowerShell) {
    $global:startCommand = "$($serviceHome)\bin\start.ps1"
    $global:stopCommand = "$($serviceHome)\bin\stop.ps1"
  } Else {
    $global:isBatch = $true;
    $global:startCommand = "$($serviceHome)\bin\$($global:serviceName).bat"
  }

  # Create the Log directory if it does not exist
  #  This may also be set in a *.bat file, but it is required here so that we can log the PowerShell output
  If ($global:isPowerShell -or $global:isBatch) {
    # PowerShell or Batch commands will live in something like:
    #    \fusionauth/fusionauth-app\/bin
    #
    # so the log directory will be up one directory from the service home
    $global:logDir = "${global:serviceHome}\..\logs"

    $serviceHomeName = (Get-Item $command).Directory.Parent.Name
    $global:serviceLogFile = "${global:logDir}\${serviceHomeName}-service.log"
  } Else {
    # Tomcat and Elasticsearch commands will live in something like:
    #    \fusionauth\fusionauth-app\apache-tomcat\bin
    #    \fusionauth\fusionauth-search\elasticsearch\bin
    #
    # so the log directory will be up two directories from the service home
    $global:logDir = "${global:serviceHome}\..\..\logs"

    $serviceHomeName = (Get-Item $command).Directory.Parent.Parent.Name
    $global:serviceLogFile = "${global:logDir}\${serviceHomeName}-service.log"
  }

  If (-Not (Test-Path $global:logDir)) {
    New-Item -ItemType Directory -Path $global:logDir
    log "  Creating log directory : ${global:logDir}"
  } Else {
    log "  Log directory : ${global:logDir} exists"
  }

  log "Service parameters:"
  log "  Command Home [$($global:serviceHome)]"
  log "  Service Name [$($global:serviceName)]"
  log "  Start Batch Command [$($global:startCommand)]"
  log "  Stop Batch Command [$($global:stopCommand)]"
}

# Is this Apache Tomcat
function isTomcatService {
  Param([string]$path)

  return Test-Path "$($path)\bin\catalina.bat"
}

# Is this a modern app with PowerShell start / stop scripts
function isPowerShellStartup {
  Param([string]$path)

  return Test-Path "$($path)\bin\start.ps1"
}

# Is this Elasticsearch
function isElasticService {
  Param([string]$path)

  return Test-Path "$($path)\bin\elasticsearch.bat"
}

# Log messages to an out file
function log {
  Param([string]$message)

  $(Get-Date -f o) + " $($message)" | Out-File $global:serviceLogFile -Append
  Write-Verbose -Message $message
}

# Take arguments when run interactively in PowerShell
#
#  run - Manually run this w/out running the service. Probably just for testing.
#  start - Start the service, assumes the service has been installed already
#  stop - Stop the service, assumes the service has been installed already
#  status - Retrieve the current status of the service, assumes the service has been installed already
#  startup
#    manual - Change Service Startup Type to Manual
#    automatic - Change Service Startup Type to Automatic
If ($args.Length -gt 0) {
  If ($args[0].equals("run")) {
    $global:windowStyle = "Normal"
    Main
  } ElseIf ($args[0].equals("start")) {
    setupGlobalVariables
    log "Start requested for service $($global:serviceName)"
    Start-Service -Name $global:serviceName
  } ElseIf ($args[0].equals("stop")) {
    setupGlobalVariables
    log "Stop requested for service $($global:serviceName)"
    Stop-Service $global:serviceName
  } ElseIf ($args[0].equals("status")) {
    setupGlobalVariables
    $status = (Get-Service -Name $global:serviceName).Status
    log "Status of $($global:serviceName) : $($status)"
  } ElseIf ($args[0].equals("startup")) {
    setupGlobalVariables
    If ($args[1].equals("manual")) {
      log "Change startup mode for $($global:serviceName) to Manual"
      Set-Service -Name $global:serviceName -StartupType Manual
    } ElseIf ($args[1].equals("automatic")) {
      log "Change startup mode for $($global:serviceName) to Automatic"
      Set-Service -Name $global:serviceName -StartupType Automatic
    }
  }
}
